// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC//           Version 0.90. August 3, 2009.
// LIC//
// LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================

#pragma once

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// OOMPH-LIB headers

// hierher uncomment these
//#include "../generic/nodes.h"
//#include "../generic/Qelements.h"
//#include "../generic/oomph_utilities.h"

#include "generic/Qelements.h"
#include "generic/nodes.h"
#include "generic/oomph_utilities.h"
#include "generic/projection.h"
#include "hele_shaw_equations.h"

//======================================================================
/// QHeleShawElement elements are linear/quadrilateral/brick-shaped
/// HeleShaw elements with isoparametric interpolation for the function.
//======================================================================
// JACK - SPECIFIC ELEMENT
template <unsigned NNODE_1D>
class QHeleShawElement : public virtual QElement<2, NNODE_1D>,
                         public virtual HeleShawEquations {
private:
  /// \short Static int that holds the number of variables at
  /// nodes: always the same
  static const unsigned Initial_Nvalue;

public:
  ///\short  Constructor: Call constructors for QElement and
  /// HeleShaw equations
  QHeleShawElement() : QElement<2, NNODE_1D>(), HeleShawEquations() {}

  /// Broken copy constructor
  QHeleShawElement(const QHeleShawElement<NNODE_1D> &dummy) {
    BrokenCopy::broken_copy("QHeleShawElement");
  }

  /// Broken assignment operator
  void operator=(const QHeleShawElement<NNODE_1D> &) {
    BrokenCopy::broken_assign("QHeleShawElement");
  }

  /// \short  Required  # of `values' (pinned or dofs)
  /// at node n
  inline unsigned required_nvalue(const unsigned &n) const {
    return Initial_Nvalue;
  }

  /// \short Output function:
  ///  x,y,u   or    x,y,z,u
  void output(std::ostream &outfile);

  ///  \short Output function:
  ///   x,y,u   or    x,y,z,u at n_plot^2 plot points
  void output(std::ostream &outfile, const unsigned &n_plot);

  /// \short C-style output function:
  ///  x,y,u   or    x,y,z,u
  void output(FILE *file_pt);

  ///  \short C-style output function:
  ///   x,y,u   or    x,y,z,u at n_plot^2 plot points
  void output(FILE *file_pt, const unsigned &n_plot);

  /// \short Output function for an exact solution:
  ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^2 plot points
  void output_fct(std::ostream &outfile, const unsigned &n_plot,
                  FiniteElement::SteadyExactSolutionFctPt exact_soln_pt);

  /// \short Output function for a time-dependent exact solution.
  ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^2 plot points
  /// (Calls the steady version)
  void output_fct(std::ostream &outfile, const unsigned &n_plot,
                  const double &time,
                  FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt);

      protected :
      /// Shape, test functions & derivs. w.r.t. to global coords. Return
      /// Jacobian.
      inline double dshape_and_dtest_eulerian_hele_shaw(const Vector<double> &s,
                                                        Shape &psi,
                                                        DShape &dpsidx,
                                                        Shape &test,
                                                        DShape &dtestdx) const;

  /// \short Shape, test functions & derivs. w.r.t. to global coords. at
  /// integration point ipt. Return Jacobian.
  inline double
  dshape_and_dtest_eulerian_at_knot_hele_shaw(const unsigned &ipt, Shape &psi,
                                              DShape &dpsidx, Shape &test,
                                              DShape &dtestdx) const;

  /// \short Shape/test functions and derivs w.r.t. to global coords at
  /// integration point ipt; return Jacobian of mapping (J). Also compute
  /// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
  inline double dshape_and_dtest_eulerian_at_knot_hele_shaw(
      const unsigned &ipt, Shape &psi, DShape &dpsidx,
      RankFourTensor<double> &d_dpsidx_dX, Shape &test, DShape &dtestdx,
      RankFourTensor<double> &d_dtestdx_dX,
      DenseMatrix<double> &djacobian_dX) const;
};

#include "hele_shaw_elements.tpp"
