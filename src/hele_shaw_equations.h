// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC//           Version 0.90. August 3, 2009.
// LIC//
// LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
#pragma once

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// OOMPH-LIB headers
#include "generic.h"
// #include "generic/Qelements.h"
// #include "generic/nodes.h"
// #include "generic/oomph_utilities.h"
// #include "generic/projection.h"

//=============================================================
/// A class for all isoparametric elements that solve the
/// HeleShaw equations.
/// \f[
/// dh_dt + div ( b^3 grad p)=0
/// \f]
/// This contains the generic maths. Shape functions, geometric
/// mapping etc. must get implemented in derived class.
//=============================================================

using namespace oomph;

// JACK - FINITE ELEMENT
class HeleShawEquations : public virtual FiniteElement {
public:
  /// \short Function pointer to function which provides h(x,t) and dh/dt, for
  /// vector x.
  typedef void (*UpperWallFctPt)(const Vector<double> &x, double &h,
                                 double &dhdt);

  typedef void (*UpperWallFluxFctPt)(const Vector<double> &x, double &h,
                                     double &dhdt, Vector<double> &dhdx,
                                     Vector<double> &d_dhdt_dx);

  /// Constructor
  HeleShawEquations() : Upper_wall_fct_pt(0), Upper_wall_flux_fct_pt(0) {}

  /// Broken copy constructor
  HeleShawEquations(const HeleShawEquations &dummy) {
    BrokenCopy::broken_copy("HeleShawEquations");
  }

  /// Broken assignment operator
  void operator=(const HeleShawEquations &) {
    BrokenCopy::broken_assign("HeleShawEquations");
  }

  /// \short Return the index at which the unknown value
  /// is stored. The default value, 0, is appropriate for single-physics
  /// problems, when there is only one variable, the value that satisfies
  /// the hele_shaw equation.
  /// In derived multi-physics elements, this function should be overloaded
  /// to reflect the chosen storage scheme. Note that these equations require
  /// that the unknown is always stored at the same index at each node.
  virtual inline unsigned p_index_hele_shaw() const { return 0; }

  /// Output with default number of plot points
  void output(std::ostream &outfile);

  /// \short Output FE representation of soln: x,y,u or x,y,z,u at
  /// n_plot^2 plot points
  void output(std::ostream &outfile, const unsigned &n_plot);

  /// C_style output with default number of plot points
  void output(FILE *file_pt);

  /// \short C-style output FE representation of soln: x,y,u or x,y,z,u at
  /// n_plot^2 plot points
  void output(FILE *file_pt, const unsigned &n_plot);

  /// Output exact soln: x,y,u_exact or x,y,z,u_exact at n_plot^2 plot points
  void output_fct(std::ostream &outfile, const unsigned &n_plot,
                  FiniteElement::SteadyExactSolutionFctPt exact_soln_pt);

  /// \short Output exact soln: x,y,u_exact or x,y,z,u_exact at
  /// n_plot^2 plot points (dummy time-dependent version to
  /// keep intel compiler happy)
  virtual void
  output_fct(std::ostream &outfile, const unsigned &n_plot, const double &time,
             FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
  {
    throw OomphLibError(
        "There is no time-dependent output_fct() for HeleShaw elements ",
        "HeleShawEquations::output_fct()", OOMPH_EXCEPTION_LOCATION);
  }

  /// Get error against and norm of exact solution
  void compute_error(std::ostream &outfile,
                     FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                     double &error, double &norm);

  /// Dummy, time dependent error checker
  void compute_error(std::ostream &outfile,
                     FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                     const double &time, double &error, double &norm);

  /// Access function: Pointer to source function
  UpperWallFctPt &upper_wall_fct_pt();

  /// Access function: Pointer to source function. Const version
  UpperWallFctPt upper_wall_fct_pt() const;

  UpperWallFluxFctPt &upper_wall_flux_fct_pt();

  UpperWallFluxFctPt upper_wall_flux_fct_pt() const;

  /// To implement the Hele-Shaw mass conservation, we need to know
  /// h and dh/dt at (Eulerian) position x.
  inline virtual void get_upper_wall_data(const unsigned &ipt,
                                          const Vector<double> &x, double &h,
                                          double &dhdt) const {
    // If no function has been set, assume constant thickness
    if (Upper_wall_fct_pt == 0) {
      // Unit gapwidth
      h = 1.0;

      // Zero velocity
      dhdt = 0.0;
    } else {
      // Get data from function
      (*Upper_wall_fct_pt)(x, h, dhdt);
    }
  }

  inline virtual void
  get_upper_wall_flux_data(const unsigned &ipt, const Vector<double> &x,
                           double &h, double &dhdt, Vector<double> &dhdx,
                           Vector<double> &d_dhdt_dx) const {
    // If no function has been set, assume constant thickness
    if (Upper_wall_flux_fct_pt == 0) {
      if (Upper_wall_fct_pt != 0) {
        /// If h(x,t) has been specified, but not the spatial gradients of
        /// these, we'll do finite differencing with respect to the two
        /// components of x.
        get_upper_wall_data(ipt, x, h, dhdt);

        for (unsigned i = 0; i < 2; i++) {
          double h_temp, dhdt_temp;
          Vector<double> x_temp = x;
          x_temp[i] = x[i] + 1e-8;
          get_upper_wall_data(ipt, x_temp, h_temp, dhdt_temp);
          dhdx[i] = (h_temp - h) / (x_temp[i] - x[i]);
          d_dhdt_dx[i] = (dhdt_temp - h) / (x_temp[i] - x[i]);
        }
      } else {
        /// If Upper_wall_fct_pt has not been set, then h defaults to one
        /// everywhere
        h = 1.0;
        dhdx[0] = 0;
        dhdx[1] = 0;
        d_dhdt_dx[0] = 0;
        d_dhdt_dx[1] = 0;
      }
    } else {
      /// The relevant gradients have been supplied explicitly.
      (*Upper_wall_flux_fct_pt)(x, h, dhdt, dhdx, d_dhdt_dx);
    }
  }

  /// Get pressure flux: gradient[i] = dp/dx_i
  /// This is useful to compute the velocity components, and can also be used
  /// as a flux vector for the Z2 error estimator (see eg
  /// Thele_shaw_elements). We could also use velocity as the flux vector for
  /// the Z2 error estimator.
  void get_pressure_gradient(const Vector<double> &s,
                             Vector<double> &gradient) const;

  /// The current nondimensionalisation has velocity[i] = -h^2 *dp/dx_i
  void get_velocity(const Vector<double> &s, Vector<double> &velocity) const;

  /// Add the element's contribution to its residual vector (wrapper)
  void fill_in_contribution_to_residuals(Vector<double> &residuals);

  /// Add the element's contribution to its residual vector and
  /// element Jacobian matrix (wrapper)
  void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                        DenseMatrix<double> &jacobian);

  /// \short Return FE representation of function value u_hele_shaw(s)
  /// at local coordinate s
  inline double interpolated_p_hele_shaw(const Vector<double> &s) const {
    // Find number of nodes
    const unsigned n_node = nnode();

    // Get the index at which the hele_shaw unknown is stored
    const unsigned p_nodal_index = p_index_hele_shaw();

    // Local shape function
    Shape psi(n_node);

    // Find values of shape function
    shape(s, psi);

    // Initialise value of u
    double interpolated_p = 0.0;

    // Loop over the local nodes and sum
    for (unsigned l = 0; l < n_node; l++) {
      interpolated_p += this->nodal_value(l, p_nodal_index) * psi[l];
    }

    return (interpolated_p);
  }

  /// \short Compute derivatives of elemental residual vector with respect
  /// to nodal coordinates. Overwrites default implementation in
  /// FiniteElement base class.
  /// dresidual_dnodal_coordinates(l,i,j) = d res(l) / dX_{ij}
  virtual void get_dresidual_dnodal_coordinates(
      RankThreeTensor<double> &dresidual_dnodal_coordinates);

  /// \short Self-test: Return 0 for OK
  unsigned self_test();

  bool *construct_mass_matrix_left_multiplier_pt;

protected:
  /// \short Shape/test functions and derivs w.r.t. to global coords at
  /// local coord. s; return  Jacobian of mapping
  virtual double dshape_and_dtest_eulerian_hele_shaw(const Vector<double> &s,
                                                     Shape &psi, DShape &dpsidx,
                                                     Shape &test,
                                                     DShape &dtestdx) const = 0;

  /// \short Shape/test functions and derivs w.r.t. to global coords at
  /// integration point ipt; return  Jacobian of mapping
  virtual double
  dshape_and_dtest_eulerian_at_knot_hele_shaw(const unsigned &ipt, Shape &psi,
                                              DShape &dpsidx, Shape &test,
                                              DShape &dtestdx) const = 0;

  /// \short Shape/test functions and derivs w.r.t. to global coords at
  /// integration point ipt; return Jacobian of mapping (J). Also compute
  /// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
  virtual double dshape_and_dtest_eulerian_at_knot_hele_shaw(
      const unsigned &ipt, Shape &psi, DShape &dpsidx,
      RankFourTensor<double> &d_dpsidx_dX, Shape &test, DShape &dtestdx,
      RankFourTensor<double> &d_dtestdx_dX,
      DenseMatrix<double> &djacobian_dX) const = 0;

  /// \short Compute element residual Vector only (if flag=and/or element
  /// Jacobian matrix
  virtual void
  fill_in_generic_residual_contribution_hele_shaw(Vector<double> &residuals,
                                                  DenseMatrix<double> &jacobian,
                                                  const unsigned &flag);

  /// Pointer to function that specifies the gap width and wall velocity
  UpperWallFctPt Upper_wall_fct_pt;

  UpperWallFluxFctPt Upper_wall_flux_fct_pt;
};

#include "hele_shaw_equations.imp"
